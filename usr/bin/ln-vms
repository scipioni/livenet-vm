#!/bin/bash

# In this script you can find a set of utilities fo ln-vm.
# Get update for all vms
# Get vm for all section defined in vms.conf

#the name of vm launcher
vmlauncher=ln-vm

#define in livenet.conf the path of server sharing
. /etc/livenet/livenet.conf

function do_help {
cat <<EOF

$0 [-h] [-r] [--sync /path/to/vm] [-g]

--help,-h: help
--list: list vm
--vm <vm> [--xsession] [--run | --guest | --rdp]
EOF
}

# all vms need some variables: name [STRING], master [PATH], update [BOOLEAN] and local [PATH]
# for every section defined in vms.conf, initialize the variables with function do_parse
# every section need a name between square []

#if there are some vms for livenet image download and install
#set -x
# get all update for every VM 
function do_parse() {
    SECTION=$1
    unset name master update dsks local
    eval $( sed -e 's/[[:space:]]*\=[[:space:]]*/=/g' \
        -e 's/;.*$//' \
        -e 's/[[:space:]]*$//' \
        -e 's/^[[:space:]]*//' \
        -e "s/^\(.*\)=\([^\"']*\)$/\1=\"\2\"/" \
       < $CONFIG_FILE \
        | sed -n -e "/^\[$SECTION\]/,/^\s*\[/{/^[^;].*\=.*/p;}" )
    dsks=$(echo ${dsks:1:-1} )
    echo $dsks
}

# get all VM 
function do_sync() {
    SECTIONS=$( sed -n -e "s/^\[\(\w\+\)\].*/\1/p" < ${CONFIG_FILE} )

    #if dataset rpool/vms does not exist, create it
    if [ "$(zfs list -o name | grep rpool/vms | wc -l)" -lt "1" ]; then
        echo "create rpool/vms"
        zfs create rpool/vms
    else
        #list of available ZVOL for vms disks. Chek
        ZFS_DONE=$(zfs list -o name | grep rpool/vms | tail -n +2)
	echo "Volumi disponibili $ZFS_DONE"
        echo "Se ci sono volumi..."
        if [ "$(zfs list -o name | grep rpool/vms | tail -n +2 | wc -l )" -gt "0" ]; then
            for z in ${ZFS_DONE}; do
		echo "  "
		echo "controllo il volume locale ${z} e verifico se sostituirlo, aggiornarlo o eliminarlo"
                for SECTION in ${SECTIONS}; do
		    echo "leggo la sezione di $CONFIG_FILE $SECTION "
                    do_parse ${SECTION}
                    for dsk in $(echo $dsks | sed "s/,/ /g"); do
			local_dsk=$(echo $z | cut -d '/' -f 3)
			hope_dsk=${dsk##*/}
			echo "disco della vm ${SECTION}: ${hope_dsk}  $local_dsk"
                        if [ "${local_dsk}" == "${hope_dsk}" ]; then
                            echo "check of update of ${dsk}"
                            if [ "${force}" == "true" ]; then
				echo $LIVENET_ROOT
				echo "arrivo a forza per clonaere $hope_dsk"
                                ssh tecnici@${LIVENET_ROOT} 'ln-sendvm --send ${hope_dsk}' | pv | sudo zfs receive rpool/vms/${dsk}
                            else
				echo "aggiorno $hope_dsk $name" 
                                update_vol $hope_dsk $name
                            fi
                        else
				echo "destroy $z"
                            zfs destroy -r ${z}
                        fi
                    done
                done
            done
        else
            for SECTION in ${SECTIONS}; do
                do_parse ${SECTION}
                for dsk in $(echo $dsks | sed "s/,/ /g"); do
		     echo $LIVENET_ROOT
		     echo $dsk
		     hope_dsk=${dsk##*/}
                     ssh tecnici@${LIVENET_ROOT} 'ln-sendvm --send ${hope_dsk}' | pv | sudo zfs receive rpool/vms/${dsk}
                done
            done

        fi

    fi 

}



function update_vol(){
    vol=$1
    name=$2
    if ping -c 1 ${LIVENET_ROOT} &> /dev/null
    then
	mkdir -p /mnt/update
        mount -t nfs ${LIVENET_ROOT}:/livenet/vms-up /mnt/update
        #get latest snapshot of local volume
        LAST=$(zfs list -o name -t snapshot | grep ${vol} | tail -1)
        
        LAST_SNAP_TS=$(echo ${LAST} | cut -d '@' -f 2)
        #apply all newer snapshot 
        for UPDATE_FILE in `ls /mnt/update/${name}/*.gz | sort`; do
            #get without extension
            NUMBERVALUE=$(echo ${UPDATE_FILE} | cut -d '.' -f 1 )
            NUMBERVALUE=${NUMBERVALUE##*/}
            if test "${NUMBERVALUE}" ">" "${LAST_SNAP_TS}"; then
                        start_time=$(date +%s)
                        zcat "${UPDATE_FILE}" | zfs receive -F rpool/vms/${vol}
                        #presuppongo che se zfs receive fallisce vale l'ultimo
                        end_time=$(date +%s)
                        #sleep 1
                        LAST_SNAP=$(zfs list -t snapshot -o name -s creation | grep ${vol} | tail -1)
                        LAST_SNAP_TS=$(echo $LAST_SNAP | cut -d '@' -f 2)
                        #echo "The system have install ${UPDATE_FILE} on the volume ${ROOT_VOLUME}, the most recent snapshot of the volume is ${LAST_SNAP}"
                        echo "  elapsed time: $(( $((end_time - start_time)) )) sec."
                        echo "Install next update"
                        #sleep 1
            fi
        done
        end_time_all=$(date +%s)
        #if fail reclone
	umount /mnt/update
    else
        exit 1
    fi
    
}


function do_list() {
    SECTIONS=$( sed -n -e "s/^\[\(\w\+\)\].*/\1/p" < ${CONFIG_FILE} )
    for SECTION in ${SECTIONS}; do
        echo "[${SECTION}]"
        do_parse ${SECTION}
        echo "  name=${name} master=${master} disks=${dsks} update=${update}"  
    done
}

#download all updates
function do_run() {
    options="$*"
    do_parse $name
    echo "running $name $master $dsks"
    export dsks
    export master
    export name
    if [ -z "${dsks}" ]; then
        echo "ERROR: no disk $local or remote disk ${master} found"
    fi 
    ${vmlauncher} ${options}
}

PROGNAME=${0##*/}
PROGVERSION=0.1.0
SHORTOPTS="h"
LONGOPTS="help,list,vm:,run,guest,xsession,sync,rdp,headless"

ARGS=$(getopt -s bash --options $SHORTOPTS --longoptions $LONGOPTS --name $PROGNAME -- "$@" )
if [ $? -ne 0 ]; then
    # bad argument
    exit 1
fi
eval set -- "$ARGS"

while true; do
   case $1 in
    -h|--help)
        do_help
        exit 0
        ;;
    --list)
        do_list
        exit 0
        ;;
    --sync)
	shift
	shift
	force=$1
       touch /tmp/longop
       ( do_sync ; rm -f /tmp/longop ) &
        sleep 5

        # long sync, switch to session-wait
       # if [ -f ${FLAGLONGOP} ]; then
        #    update-alternatives --set lightdm.conf /etc/lightdm/lightdm.conf.nfs.special
        #    service lightdm restart

         #   while [ 1 ]; do
          #      sleep 5
           #     [ -f ${FLAG} ] && continue # until sync running

                # activate normal login
 
         #      do_update_alternatives /etc/lightdm/lightdm.conf
#                service lightdm restart
          #      break
          #  done
       # fi
        exit 0
        ;;
    --vm)
        shift
        name=$1
        ;;
    --run)
        [ -n "${name}" ] || break
        do_parse "${name}"
        ;;
    --guest)
        [ -n "${name}" ] || break
        do_parse "${name}"
        OPTIONS="${OPTIONS} --fullscreen --guest --spice"
        XSESSION=true
        ;;
    --headless)
        [ -n "${name}" ] || break
        do_parse "${name}"
        OPTIONS="${OPTIONS} --guest --headless"
        XSESSION=false
        ;;
    --rdp)
        [ -n "${name}" ] || break
        do_parse "${name}"
        OPTIONS="${OPTIONS} --rdp"
        RDP=true
        ;;
    --xsession)
        XSESSION=true
        ;;
    *)
        shift
        break
        ;;
   esac
   shift
done
    

if [ -n "${XSESSION}" ]; then
   ratpoison -f /etc/ratpoisonrc &
   wmpid=$!
   if [ -n "${RDP}" ]; then
       do_setbg
       for i in $( seq 10 10 100 ); do
           sleep 2
           echo $i
       done | zenity --progress --no-cancel --auto-close --width 400 --text "Attendere ..." &
   fi#

   ( do_run ${OPTIONS} ; killall ratpoison ) &
   wait $wmpid # wait until ratpoison is closed after do_run
else
   do_run ${OPTIONS}
fi
